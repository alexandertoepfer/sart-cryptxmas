#include <stdlib.h>
#include <time.h>
#include <algorithm>
#include <stdexcept>
#include <iostream>
#include <iomanip>
#include <cstring>
#include <string>
#include <vector>
#include <list>
#include <map>

using namespace std;

/*
 * Reverse engineering cryptography challenge (2022)
 *
 *    .-.                                 .-.
 *   /   \       .-.     _     .-.       /   \
 * -/-----\-----/---\---/-\---/---\-----/-----\-
 *         \   /     `-'   `-'     \   /
 *          `-'                     `-'
 * Find the matching input string for the given output string,
 * which is produced by a hash function f with weak implemented avalanche,
 * this simple implementation can be exploited by reversing the hash.
 *
 * Author: Alexander TÃ¶pfer (https://github.com/alexandertoepfer)
 * Artwork by (https://www.asciiart.eu/)
 */

int P = 94; // Permutation(1)
int Q = 18; // Block size
int R = 18; // Rounds
// Amount of possible inputs P^18 => 328.323.043.381.011.570.137.010.813.347.823.616

unsigned char a[] = {
    0x20,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
    0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x61,0x62,0x63,0x64,0x65,
    0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,0x71,0x72,0x73,0x74,0x75,
    0x76,0x77,0x78,0x79,0x7a,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x30,0x24,
    0x25,0x26,0x40,0x23,0x7e,0x3d,0x2b,0x2d,0x2a,0x3c,0x3e,0x5b,0x5d,0x7b,0x7d,0x28,
    0x29,0x7c,0x21,0x3f,0x22,0x27,0x60,0x5e,0x2c,0x2e,0x3b,0x3a,0x2f,0x5c
};

unsigned char l[] = {
    0xff,0xff,0x00,0x00,0xff,0xff,0x00,0x00,0xff,0xff,0x00,0x00,0xff,0xff,0x00,0x00,
    0x00,0x00,0xff,0xff,0x00,0x00,0xff,0xff,0x00,0x00,0xff,0xff,0x00,0x00,0xff,0xff,
    0x00,0x52,0x54,0x43,0x3f,0x40,0x41,0x55,0x4f,0x50,0x48,0x46,0x58,0x47,0x59,0x5c,
    0x3e,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x5b,0x5a,0x49,0x45,0x4a,0x53,
    0x42,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x4b,0x5d,0x4c,0x57,0x00,
    0x56,0x1b,0x1c,0x1d,0x1e,0x1f,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,
    0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,0x30,0x31,0x32,0x33,0x34,0x4d,0x51,0x4e,0x44,0x00,
    0xff,0xff,0x00,0x00,0xff,0xff,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0xff,0xff,0x00,0x00,0xff,0xff,0x00,0x00,0xff,0xff,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0xff,0xff,0x00,0x00,0xff,0xff,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0xff,0xff,0x00,0x00,0xff,0xff,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0xff,0xff,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,0xff,0xff,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff
};

unsigned char s[] = {
    0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,
    0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,
    0x33,0x44,0x46,0x30,0x26,0x53,0x38,0x2a,0x43,0x61,0x31,0x74,0x36,0x3f,0x3b,0x2d,
    0x41,0x48,0x4c,0x5c,0x28,0x23,0x24,0x4e,0x40,0x71,0x7c,0x70,0x39,0x2f,0x69,0x65,
    0x6b,0x63,0x47,0x76,0x58,0x7e,0x79,0x51,0x35,0x4f,0x75,0x49,0x57,0x6f,0x2c,0x22,
    0x7a,0x29,0x2b,0x3d,0x55,0x21,0x73,0x34,0x3c,0x67,0x72,0x64,0x62,0x3a,0x68,0x00,
    0x4b,0x59,0x5a,0x54,0x52,0x5b,0x5e,0x7b,0x6a,0x4d,0x6e,0x32,0x78,0x50,0x20,0x77,
    0x37,0x6c,0x5d,0x42,0x60,0x56,0x2e,0x7d,0x27,0x25,0x45,0x3e,0x6d,0x4a,0x66,0x00,
    0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,
    0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,
    0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,
    0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,
    0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,
    0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,
    0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,
    0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff,0x00,0xff
};

vector<vector<int>> d = {
    {0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x00,0x01,0x00,0x00,0x00},
    {0x01,0x01,0x00,0x01,0x01,0x01,0x01,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x00,0x01,0x00,0x00,0x01},
    {0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00},
    {0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00},
    {0x00,0x00,0x01,0x01,0x00,0x01,0x00,0x00,0x01,0x01,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00},
    {0x01,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x00,0x01,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x00,0x01,0x01,0x00,0x01,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x01},
    {0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00},
    {0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x00,0x01,0x00,0x01,0x00},
    {0x00,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x00,0x00},
    {0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x00},
    {0x01,0x01,0x01,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00},
    {0x01,0x00,0x00,0x01,0x01,0x00,0x00,0x01,0x01,0x00,0x01,0x00,0x00,0x00,0x01,0x01,0x00,0x00},
    {0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x01}
};

// f(text[18]) -> hash[18]
unsigned char* f(unsigned char i[]) {
    unsigned char* o = new unsigned char[Q];
    int j,k;
    for(j=0;j<Q;j++)
        o[j]=i[j];
    for(j=0;j<R;j++) {
        for(k=0;k<Q;k++)
            o[k]=s[o[k]];
        for(k=0;k<Q/2;k++)
            o[k]=a[(l[o[k]]+l[o[(Q/2)+k]])%P];
        for(k=0;k<Q;k++)
            o[k]=a[(l[o[k]]+d[j][k])%P];
    }
    return o;
}

void fRefactor(unsigned char input[18], unsigned char output[18]) {
  int j,k;
  // Copy input into output
  for(j = 0; j < Q; j++) {
    output[j] = input[j];
  }
  for(j = 0; j < R; j++) {
    // Substitute one character with another
    for(k = 0; k < Q; k++) {
      output[k] = s[output[k]];
    }
    // Combine every second character with another
    //output[0] = a[(l[output[0]] + l[output[11]]) % P];
    /*...*/
    o[0x00] = a[(l[o[0x00]] + l[o[0x0B]]) % P];
    o[0x02] = a[(l[o[0x02]] + l[o[0x0D]]) % P];
    o[0x04] = a[(l[o[0x04]] + l[o[0x0F]]) % P];
    o[0x06] = a[(l[o[0x06]] + l[o[0x11]]) % P];
    o[0x08] = a[(l[o[0x08]] + l[o[0x01]]) % P];
    o[0x0A] = a[(l[o[0x0A]] + l[o[0x03]]) % P];
    o[0x0C] = a[(l[o[0x0C]] + l[o[0x05]]) % P];
    o[0x0E] = a[(l[o[0x0E]] + l[o[0x07]]) % P];
    o[0x10] = a[(l[o[0x10]] + l[o[0x09]]) % P];
    // Shift by constant values Q times and modulus by P
    for(k = 0; k < Q; k++) {
      output[k] = a[l[output[k]] + d[j][k] % P];
    }
  }
}

void fInverse(unsigned char input[], unsigned char output[],
              map<unsigned char, unsigned char>& inverseSub,
              string (*toString)(unsigned char[]),
              bool verbose) {
  int i,j;
	auto modSub = [&](int a, int b) -> int {
    //?
	};
    for(i = 0; i < Q; i++)
        output[i] = input[i];
    for(i = R - 1; i >= 0; i--) {
        // Inverse diffusion
        for(j = Q - 1; j >= 0; j--) {
            output[j] = a[modSub(l[output[j]], d[i][j])];
        }
        if(verbose) cout << "inverse Diffusion:     " << toString(output) << endl;
        // Inverse mix
        for(j = (Q / 2) - 1; j >= 0; j--) {
            output[j] = a[modSub(l[output[j]], l[output[(Q/2) + j]])];
        }
        if(verbose) cout << "inverse Mix Character: " << toString(output) << endl;
        // Inverse substitution
        for(j = 0; j < Q; j++)
            output[j] = inverseSub[output[j]];
        if(verbose) cout << "inverse Substitution:  " << toString(output) << endl;
    }
}

int main() {
	auto toString = [](unsigned char str[]) -> string {
		string result;
		for(int i = 0; i < Q; i++)
			result += ((char)str[i]);
		return result;
	};
	map<unsigned char, unsigned char> subBox {
      //?
    };
	map<unsigned char, unsigned char> invBox;

  unsigned char input[19], output[19];
  output[18] = input[18] = '\0';
  string result = "2V]0>V.IyE?cHFv3|?";
  strcpy((char*) input, result.c_str());

  fInverse(input, output, invBox, toString, true);
  cout << "t(out=\"" + result + "\") -> in=\"" << output << '"' << endl;
  return 0;
}
